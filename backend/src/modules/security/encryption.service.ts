import {
  Injectable,
  Logger,
  InternalServerErrorException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const TAG_LENGTH = 16;
const SALT_LENGTH = 64;
const KEY_LENGTH = 32;
const ITERATIONS = 310_000;

/**
 * Enterprise-grade encryption service using AES-256-GCM with PBKDF2-derived keys.
 * Provides field-level encryption for PII and sensitive financial data.
 */
@Injectable()
export class EncryptionService {
  private readonly logger = new Logger(EncryptionService.name);
  private readonly masterKey: Buffer;

  constructor(private configService: ConfigService) {
    const keyHex = this.configService.get<string>('SECURITY_ENCRYPTION_KEY');
    if (!keyHex) {
      throw new Error('SECURITY_ENCRYPTION_KEY is required');
    }
    if (keyHex.length < 64) {
      throw new Error(
        'SECURITY_ENCRYPTION_KEY must be at least 64 hex characters (256-bit)',
      );
    }
    this.masterKey = Buffer.from(keyHex.slice(0, 64), 'hex');
  }

  /**
   * Encrypt a plaintext string.
   * Returns a base64-encoded payload: salt|iv|authTag|ciphertext
   */
  encrypt(plaintext: string): string {
    try {
      const salt = crypto.randomBytes(SALT_LENGTH);
      const iv = crypto.randomBytes(IV_LENGTH);
      const derivedKey = this.deriveKey(this.masterKey, salt);

      const cipher = crypto.createCipheriv(ALGORITHM, derivedKey, iv, {
        authTagLength: TAG_LENGTH,
      });

      const encrypted = Buffer.concat([
        cipher.update(plaintext, 'utf8'),
        cipher.final(),
      ]);
      const authTag = cipher.getAuthTag();

      const payload = Buffer.concat([salt, iv, authTag, encrypted]);
      return payload.toString('base64');
    } catch (error) {
      this.logger.error('Encryption failed', error);
      throw new InternalServerErrorException('Encryption failed');
    }
  }

  /**
   * Decrypt a base64-encoded payload produced by encrypt().
   */
  decrypt(encryptedBase64: string): string {
    try {
      const payload = Buffer.from(encryptedBase64, 'base64');

      const salt = payload.subarray(0, SALT_LENGTH);
      const iv = payload.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
      const authTag = payload.subarray(
        SALT_LENGTH + IV_LENGTH,
        SALT_LENGTH + IV_LENGTH + TAG_LENGTH,
      );
      const ciphertext = payload.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);

      const derivedKey = this.deriveKey(this.masterKey, salt);

      const decipher = crypto.createDecipheriv(ALGORITHM, derivedKey, iv, {
        authTagLength: TAG_LENGTH,
      });
      decipher.setAuthTag(authTag);

      const decrypted = Buffer.concat([
        decipher.update(ciphertext),
        decipher.final(),
      ]);
      return decrypted.toString('utf8');
    } catch (error) {
      this.logger.error('Decryption failed', error);
      throw new InternalServerErrorException('Decryption failed');
    }
  }

  /**
   * Hash sensitive data deterministically for indexing (HMAC-SHA256).
   * Use this for lookups on encrypted fields (e.g., email search).
   */
  hash(value: string): string {
    return crypto
      .createHmac('sha256', this.masterKey)
      .update(value.toLowerCase())
      .digest('hex');
  }

  /**
   * Generate a cryptographically secure random token.
   */
  generateSecureToken(bytes: number = 32): string {
    return crypto.randomBytes(bytes).toString('hex');
  }

  /**
   * Generate a time-based HMAC token for use in signed URLs / webhooks.
   */
  generateSignedToken(
    payload: string,
    expiresInSeconds: number = 3600,
  ): string {
    const expires = Math.floor(Date.now() / 1000) + expiresInSeconds;
    const data = `${payload}:${expires}`;
    const signature = crypto
      .createHmac('sha256', this.masterKey)
      .update(data)
      .digest('hex');
    return Buffer.from(`${data}:${signature}`).toString('base64url');
  }

  /**
   * Verify a signed token generated by generateSignedToken().
   */
  verifySignedToken(token: string, payload: string): boolean {
    try {
      const decoded = Buffer.from(token, 'base64url').toString('utf8');
      const parts = decoded.split(':');
      if (parts.length !== 3) return false;

      const [tokenPayload, expiresStr, signature] = parts;
      if (tokenPayload !== payload) return false;

      const expires = parseInt(expiresStr, 10);
      if (Date.now() / 1000 > expires) return false;

      const data = `${tokenPayload}:${expiresStr}`;
      const expectedSignature = crypto
        .createHmac('sha256', this.masterKey)
        .update(data)
        .digest('hex');

      return crypto.timingSafeEqual(
        Buffer.from(signature, 'hex'),
        Buffer.from(expectedSignature, 'hex'),
      );
    } catch {
      return false;
    }
  }

  /**
   * Derive a key from a master key and salt using PBKDF2.
   */
  private deriveKey(masterKey: Buffer, salt: Buffer): Buffer {
    return crypto.pbkdf2Sync(masterKey, salt, ITERATIONS, KEY_LENGTH, 'sha256');
  }
}
